#!/usr/bin/env python

# For convenience, it is best to use VariantDir with SConscript file
#
# https://bitbucket.org/scons/scons/wiki/VariantDir%28%29
# Note that when you're not using an SConscript file in the src subdirectory,
# you must actually specify that the program must be built from the build/hello.c file
# that SCons will duplicate in the build subdirectory.

import os
import StringIO
# SCons is used explicitly
import SCons
import buildhelper as bh
from buildhelper import linkdep

EnsurePythonVersion(2, 7)

g_node_list_type = SCons.Node.NodeList


# Configurations for various build
class BuildConfig(object):
    def __init__(self, variant_dir, cons_vars):
        """
        variant_dir     Path to the variant dir.
        cons_vars       {'construction variable' : value}
        """
        assert isinstance(variant_dir, str)
        assert isinstance(cons_vars, dict)
        self.variant_dir = variant_dir
        self.cons_vars = cons_vars
        pass


class BuildEnv(object):
    """
    Build enviroment for all builds.
    """
    COMMON_CONSTR_VARS = {
        'CXXFLAGS': ['-std=c++11']
    }
    RELEASE_CONSTR_VARS = {}
    COVERAGE_CONSTR_VARS = {}
    DEBUG_CONSTR_VARS = {
        'CCFLAGS': ['-g']
    }

    @staticmethod
    def __add_build_vars(env):
        """
        Return Variables instance.
        """
        assert isinstance(env, Environment)
        vs = Variables(None, ARGUMENTS)
        vs.Add(ListVariable(key='build', help='build type', default='debug',
                            names=('release', 'coverage', 'debug'), map={}))
        vs.Add(EnumVariable(key='stage', help='build stage', default='compile',
                            allowed_values=('compile', 'link'), map={}, ignorecase=0))
        vs.Update(env)
        Help(vs.GenerateHelpText(env))
        pass

    def __init__(self, src_dir):
        """
        src_dir         source directory
        """
        self.src_dir = src_dir
        self.static_lib_dirs, self.app_main_srcs = bh.dirs_c_cpp_sources(src_dir)

        self.common_env = Environment(CPPPATH=[self.src_dir])
        self.common_env.Append(**self.COMMON_CONSTR_VARS)
        self.__add_build_vars(self.common_env)

        # { static lib dir : [c/c++ sources] }
        self.__static_lib_srcs_map = {}
        for each in self.static_lib_dirs:
            self.__static_lib_srcs_map[each] = bh.c_cpp_sources(each)
        pass

    def in_compile_stage(self):
        return self.common_env['stage'] == 'compile'

    def in_link_stage(self):
        return self.common_env['stage'] == 'link'

    def static_lib_srcs(self, lib_dir_path):
        """
        Return [static lib source path] with given lib_dir_path.
        The lib_dir_path must be from a valid static_lib_dir, otherwise, raise KeyError.
        """
        return self.__static_lib_srcs_map[lib_dir_path]

    def build_configs(self):
        """
        Return [BuildConfig instance]
        """
        def pick_constr_vars(build_type):
            if build_type == 'release':
                return self.RELEASE_CONSTR_VARS
            elif build_type == 'coverage':
                return self.COVERAGE_CONSTR_VARS
            else:
                assert build_type == 'debug'
                return self.DEBUG_CONSTR_VARS

        return map(
            lambda bt: BuildConfig(os.path.join('obj', bt), pick_constr_vars(bt)),
            set(self.common_env['build']))

    def __str__(self):
        """
        Retrn a string which is the statics of this class.
        """
        indent = "    "
        sio = StringIO.StringIO()

        print >> sio, "Static Library Directories and Sources"
        for each_dir in self.static_lib_dirs:
            print >> sio, indent, each_dir

            for each_src in self.static_lib_srcs(each_dir):
                print >> sio, indent * 2, each_src

        print >> sio, "Application Main Sources"
        for each_src in self.app_main_srcs:
            print >> sio, indent, each_src

        return sio.getvalue()


class Build(object):
    """
    Build apps.
    """
    def __init__(self, build_env, build_cfg):
        """
        build_env   A BuildEnv instance.
        build_cfg   A BuildConfig instance.
        """
        self.__build_env = build_env
        self.__build_cfg = build_cfg
        self.__env = self.__build_env.common_env.Clone()
        self.__env.Append(**self.__build_cfg.cons_vars)
        self.__env.VariantDir(self.__build_cfg.variant_dir, self.__build_env.src_dir, duplicate=0)
        pass

    def __to_build_path(self, src_path):
        if isinstance(src_path, str):
            return bh.replace_top_dir(src_path, self.__build_cfg.variant_dir)
        else:
            assert isinstance(src_path, list)
            return map(lambda x: bh.replace_top_dir(x, self.__build_cfg.variant_dir), src_path)

    def build_static_libs(self):
        """
        Return a list of static libraries targets.
        """
        def build_one_static_lib(acc, lib_dir):
            lib_name = os.path.join(lib_dir, os.path.basename(lib_dir))
            static_lib_target = self.__env.StaticLibrary(
                self.__to_build_path(lib_name),
                self.__to_build_path(self.__build_env.static_lib_srcs(lib_dir)))
            assert isinstance(static_lib_target, g_node_list_type)
            acc.extend(static_lib_target)
            return acc

        return reduce(build_one_static_lib, self.__build_env.static_lib_dirs, g_node_list_type())

    @staticmethod
    def __linked_static_lib_targets(app_main_obj_targets, static_lib_targets):
        """
        Return [necessary static lib targets]
        app_main_obj_targets    [app main obj target node]
        static_lib_targets      [static lib target node]
        """
        assert isinstance(app_main_obj_targets, g_node_list_type) and len(app_main_obj_targets) == 1
        assert isinstance(static_lib_targets, g_node_list_type)

        app_main_obj_node = app_main_obj_targets[0]
        app_main_obj_path = str(app_main_obj_node)

        # {lib path : target node}
        lib_path_node_map = dict(map(lambda n: (str(n), n), static_lib_targets))

        ordered_bins = linkdep.resolve(app_main_obj_path, lib_path_node_map.keys())
        return map(lambda p: lib_path_node_map[p],
                   filter(lambda p: p != app_main_obj_path, ordered_bins))

    def build_app_main_objs(self):
        """
        Construct app main source object targets.
        """
        def build_one_app_main_obj(acc, app_main_src):
            app_main_obj = self.__env.Object(self.__to_build_path(app_main_src))
            assert isinstance(app_main_obj, g_node_list_type)
            acc.extend(app_main_obj)
            return acc

        return reduce(build_one_app_main_obj, self.__build_env.app_main_srcs, g_node_list_type())

    def build_apps(self, app_main_obj_targets, static_lib_targets):
        """
        Construct app targets.
        app_main_obj_targets    [app main obj target]
        static_lib_targets      [static library target]
        """
        def build_one_app(acc, app_main_obj):
            app_name, _ = os.path.splitext(str(app_main_obj))

            if False:
                self.__linked_static_lib_targets(app_main_obj, static_lib_targets)

            app_main_target = self.__env.Program(app_name, app_main_obj, LIBS=static_lib_targets)
            assert isinstance(app_main_target, g_node_list_type)
            acc.extend(app_main_target)
            return acc

        return reduce(build_one_app, app_main_obj_targets, g_node_list_type())

    def build(self):
        """
        Return (compile targets, link targets)
        Construct all builds.
        """
        static_lib_targets = self.build_static_libs()
        app_main_obj_targets = self.build_app_main_objs()
        app_targets = self.build_apps(app_main_obj_targets, static_lib_targets)

        self.__env.Alias('compile', static_lib_targets + app_main_obj_targets)
        self.__env.Alias('link', app_targets)
        pass


def main():
    SOURCE_DIR = 'src'
    build_env = BuildEnv(SOURCE_DIR)

    if not GetOption('help'):
        if build_env.in_compile_stage():
            print bh.text_box("Compile")
            print build_env
        else:
            assert build_env.in_link_stage()
            print bh.text_box("Link")

    for each in build_env.build_configs():
        build = Build(build_env, each)
        build.build()

main()
