#!/usr/bin/env python

# For convenience, it is best to use VariantDir with SConscript file
#
# https://bitbucket.org/scons/scons/wiki/VariantDir%28%29
# Note that when you're not using an SConscript file in the src subdirectory, you must actually specify that the program must be built from the build/hello.c file that SCons will duplicate in the build subdirectory.

import os
import StringIO
# SCons is used explicitly
import SCons
import buildhelper as bh
from buildhelper import linkdep

EnsurePythonVersion(2, 7)


class BuildEnv(object):
    """
    Build enviroment for all builds.
    """
    def __init__(self, src_dir):
        """
        src_dir         source directory
        """
        self.src_dir = src_dir
        self.static_lib_dirs, self.app_main_srcs = bh.dirs_c_cpp_sources(src_dir)
        self.common_env = Environment(
            CPPPATH=[self.src_dir],
            CXXFLAGS=['-std=c++11'])

        # { static lib dir : [c/c++ sources] }
        self.__static_lib_srcs_map = {}
        for each in self.static_lib_dirs:
            self.__static_lib_srcs_map[each] = bh.c_cpp_sources(each)
        pass

    def static_lib_srcs(self, lib_dir_path):
        """
        Return [static lib source path] with given lib_dir_path.
        The lib_dir_path must be from a valid static_lib_dir, otherwise, raise KeyError.
        """
        return self.__static_lib_srcs_map[lib_dir_path]

    def __str__(self):
        """
        Retrn a string which is the statics of this class.
        """
        indent = "    "
        sio = StringIO.StringIO()

        print >> sio, "Static Library Directories and Sources"
        for each_dir in self.static_lib_dirs:
            print >> sio, indent, each_dir

            for each_src in self.static_lib_srcs(each_dir):
                print >> sio, indent * 2, each_src

        print >> sio, "Application Main Sources"
        for each_src in self.app_main_srcs:
            print >> sio, indent, each_src

        return sio.getvalue()


class Build(object):
    """
    Build apps.
    """
    def __init__(self, build_env, variant_dir):
        """
        build_env       A BuildEnv instance.
        variant_dir     build directory
        """
        self.__build_env = build_env
        self.__env = self.__build_env.common_env.Clone()
        self.__variant_dir = variant_dir
        self.__env.VariantDir(self.__variant_dir, self.__build_env.src_dir, duplicate=0)
        pass

    def __to_build_path(self, src_path):
        if isinstance(src_path, str):
            return bh.replace_top_dir(src_path, self.__variant_dir)
        else:
            assert isinstance(src_path, list)
            return map(lambda x: bh.replace_top_dir(x, self.__variant_dir), src_path)

    def __build_static_libs(self):
        """
        Return a list of static libraries targets.
        """
        node_list_type = SCons.Node.NodeList

        def build_one_static_lib(acc, lib_dir):
            lib_name = os.path.join(lib_dir, os.path.basename(lib_dir))
            static_lib_target = self.__env.StaticLibrary(
                self.__to_build_path(lib_name),
                self.__to_build_path(self.__build_env.static_lib_srcs(lib_dir)))
            assert isinstance(static_lib_target, node_list_type)
            acc.extend(static_lib_target)
            return acc

        return reduce(build_one_static_lib, self.__build_env.static_lib_dirs, node_list_type())

    @staticmethod
    def __linked_static_lib_targets(app_main_obj_targets, static_lib_targets):
        """
        Return [necessary static lib targets]
        app_main_obj_targets    [app main obj target node]
        static_lib_targets      [static lib target node]
        """
        node_list_type = SCons.Node.NodeList
        assert isinstance(app_main_obj_targets, node_list_type) and len(app_main_obj_targets) == 1
        assert isinstance(static_lib_targets, node_list_type)

        app_main_obj_node = app_main_obj_targets[0]
        app_main_obj_path = str(app_main_obj_node)

        # {lib path : target node}
        lib_path_node_map = dict(map(lambda n: (str(n), n), static_lib_targets))

        ordered_bins = linkdep.resolve(app_main_obj_path, lib_path_node_map.keys())
        return map(lambda p: lib_path_node_map[p],
                   filter(lambda p: p != app_main_obj_path, ordered_bins))

    def __build_apps(self, static_lib_targets):
        """
        Construct app targets.
        static_lib_targets  [static library targets]
        """
        for app_src in self.__build_env.app_main_srcs:
            app_name, _ = os.path.splitext(app_src)
            app_main_obj = self.__env.Object(self.__to_build_path(app_src))

            if False:
                self.__linked_static_lib_targets(app_main_obj, static_lib_targets)

            self.__env.Program(self.__to_build_path(app_name), app_main_obj, LIBS=static_lib_targets)
        pass

    def build(self):
        """
        Construct all targets.
        """
        static_lib_targets = self.__build_static_libs()
        self.__build_apps(static_lib_targets)
        pass


SOURCE_DIR = 'src'
VARIANT_DIR = 'obj'


build_env = BuildEnv(SOURCE_DIR)
print build_env

build = Build(build_env, VARIANT_DIR)
build.build()
